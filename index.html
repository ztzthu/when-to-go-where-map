<!DOCTYPE html>
<html>
<head>
    <title>When-to-go-where Map : Visualization of the best travel month</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.2/dist/leaflet.css"
    integrity="sha256-sA+zWATbFveLLNqWO2gtiw3HL/lh1giY/Inf1BJ0z14="
    crossorigin=""/>

    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://unpkg.com/d3-simple-slider"></script>

    <script src="https://unpkg.com/leaflet@1.9.2/dist/leaflet.js"
        integrity="sha256-o9N1jGDZrf5tS+Ft4gbIK7mYMipq9lqpVJ91xHSyKhg="
        crossorigin="">
    </script>
    <script src="https://npmcdn.com/geotiff@0.3.6/dist/geotiff.js"></script> 
    <script src="https://ihcantabria.github.io/Leaflet.CanvasLayer.Field/dist/leaflet.canvaslayer.field.js"></script>
    <!-- <script type="module" src="canvaslayer/_main.js"></script> -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.1.0/chroma.min.js"></script>
    <!-- <script src="data/world.js"></script> -->

    <!-- No zoom in -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" /> 

    <style>
        #map { 
          position: absolute;
          width: 100%; 
          top: 100px;
          /* height: 90vh;  */
          bottom: 0;
          z-index: 2;
          /* margin-top: 0.5em; */
        }
        body { 
          font: 16px/1.4 "Helvetica Neue", Arial, sans-serif;
          margin: 0; padding: 0;
        }
        html {
          margin: 0; padding: 0;
        }
        .ghbtns { position: relative; top: 4px; margin-left: 5px; }
        a { color: #0077ff; }
        .info {
            padding: 6px 8px;
            font: 14px/16px Arial, Helvetica, sans-serif;
            background: white;
            background: rgba(255,255,255,0.8);
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            border-radius: 5px;
        }
        h3{
            padding-left: 20px;
            margin-bottom: 10px;
        }
        .checkbox{
          padding-left: 1em;
        }
        .info h4  {
            margin: 0 0 5px;
            color: #777;
        }
        .collapse{
            color: rgb(0, 00, 255);
            text-decoration: underline;
        }
        .paragraph{
            margin-right: 20px;
            margin-left: 20px;
            border-left: 4px solid grey;
            padding-left: 10px;
        }
        #slider{
          position: absolute; 
          bottom: 10px;
          left: 10px;
          z-index: 1000;
          background-color: #fff;
          height: 65px;
          border-radius: 2px;
          border: 2px solid rgba(0,0,0,0.2);
          background-clip: padding-box;
        }
        #checkbox{
          margin-left: 20px;
        }
        /* #checkbox-caption{
          margin-left: 20px;
        } */
        #chart{
          position: absolute;
          right: 10px;
          top: 110px;
          width: 260px;
          height: 260px;
          z-index: 1000;
          background-color: #fff;
          /* opacity: 0%; */
          border-radius: 2px;
          border: 2px solid rgba(0,0,0,0.2);
          background-clip: padding-box;
          display: none;
        }

        .close {
          position: absolute;
          right: 20px;
          top: 120px;
          width: 5px;
          height: 5px;
          opacity: 0.3;
          z-index: 1001;
        }
        .close:hover {
          opacity: 1;
        }
        .close:before, .close:after {
          position: absolute;
          left: 0px;
          content: ' ';
          height: 10px;
          width: 2px;
          background-color: #333;
        }
        .close:before {
          transform: rotate(45deg);
        }
        .close:after {
          transform: rotate(-45deg);
        }
    </style>
</head>
<body>

<h3>‚òÄÔ∏èüåßÔ∏èü•∂ü•µ   <i>WHEN-to-go-WHERE-map</i>‚Ñ¢</h3>

<input type="checkbox" id="checkbox" name="relative" value="true" onclick="render_map()" checked>
<label for="true">I already know where to go, tell me the best month!</label>

<!-- <span id="value" style="display: inline-block; text-align: right;">Janurary</span> -->


<br>


<div id="slider"></div> 
<div id="map"></div>
<div id="chart"></div>
<a href="#" onclick="document.getElementById('chart').style.display = 'none'" class="close"></a> 




<script>

  // Basemap
  var map = L.map("map").setView([50, 20], 3);
  var url = 'https://stamen-tiles.a.ssl.fastly.net/toner/{z}/{x}/{y}.png';
  L.tileLayer(url, {
    attribution: "OSM & Carto",
    subdomains: "abcd",
    maxZoom: 6
  }).addTo(map);

  var month_name = ['Janurary', 'Feburary', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']

  var relativeMap;

  var current_month;

  function render_map(month){
    if (typeof month ==="undefined"){
      month = current_month;
    }
    current_month = month;
    if (typeof relativeMap !== 'undefined'){
      map.removeLayer(relativeMap);
    }

    const checkBox = document.getElementById('checkbox');

    if(checkBox.checked){
      var tiff = "https://ztzthu.github.io/when-to-go-where-map/data/relative_" + month + ".tif";
    } else {
      var tiff = "https://ztzthu.github.io/when-to-go-where-map/data/absolute_" + month + ".tif";
    }

    d3.request(tiff).responseType('arraybuffer').get(
            function (error, tiffData) {
                let s = L.ScalarField.fromGeoTIFF(tiffData.response);
                // s.setSpatialMask(world_mask["features"][5]);
                console.log(s.range)

                relativeMap = L.canvasLayer.scalarField(s, {
                    opacity: 0.5,
                    color: chroma.scale(['#272ad7', '#27d7d7', '#2ad727', '#d7d727', '#d73027']).domain([0, 100]),
                    interpolate: false
                }).addTo(map);

                relativeMap.on('click', function (e) {
                    if (isNaN(e.value) == false) {
                        let v = e.value.toFixed(2);
                        let html = (`<span class="popupText">Score of ` + month_name[month-1] + `: ${v}</span>`);
                        let popup = L.popup()
                            .setLatLng(e.latlng)
                            .setContent(html)
                            .openOn(map);
                    }
                });
                // map.fitBounds(layer.getBounds());




                // Layer Control
                // L.control.layers({
                //     "December": relativeMap,
                //     "December": relativeMap
                // }, {}, {
                //     position: 'topright',
                //     collapsed: false
                //     }).addTo(map);


            });




  }

  // add right-click behaviour
  var svg_chart = d3.select("#chart")
    // .attr("opacity", "100%")
    .append("svg")
      .attr("width", 260)
      .attr("height", 260)
    .append("g")
      .attr("transform", "translate(30,35)");

  var debug;

  d3.csv("./data/all_score.csv", 
    function(data){
      function onMapClick(e){
        var lat = e.latlng.lat;
        var lng = e.latlng.lng;
        // map precision 0.5 by 0.5
        var intlat = parseInt(lat + 90) * 2;
        var intlng = parseInt(lng + 180) * 2;
        // var intlng = lng < 0 ? parseInt(lng + 360) : parseInt(lng);
        // document.getElementById("value").innerHTML = intlat * 100000 + intlng;
        var id_start = 12 * intlng + 12 * 720 * intlat;
        var climate_data = [];

        // invalid data
        if(isNaN(data[id_start].mintemp)){
          svg_chart.selectAll("*").remove();
          document.getElementById('chart').style.display = 'none';
          return 0;
        }
        for(let m = 0; m < 12; m++){
          var current_data = m < 12 ? data[m + id_start] : data[m - 12 + id_start];
          // console.log(current_data)
          climate_data.push({"month": m+1, 
                             "mintemp": current_data.mintemp, 
                             "maxtemp": current_data.maxtemp, 
                             "precipitation": current_data.precipitation, 
                             "wetdays" : current_data.wetdays});
        }
        // console.log(wetdays);

        height = 200;
        // create axis
        document.getElementById('chart').style.display = 'block'
        svg_chart.selectAll("*").remove();
        var x = d3.scaleLinear()
          .domain([0.5,12.5])
          .range([0, height]);
        svg_chart.append("g")
          .attr('transform', 'translate(' + 0 + ',' + height + ')')
          .attr('class', 'xAxis')
          .call(d3.axisBottom(x)
            // .ticks(d3.timeMonth.every(1))
            // .tickFormat(d3.timeFormat("%b"))
          )


        var y_temp = d3.scaleLinear()
          .domain([d3.min(climate_data, d => parseFloat(d.mintemp)) - 10, d3.max(climate_data, d => parseFloat(d.maxtemp)) + 10])
          .range([height, 0]);
        svg_chart.append("g")
          .attr('class', 'yAxisTemp')
          .call(d3.axisLeft(y_temp));

        // svg_chart.selectAll(".yAxisTemp").transition()
        //   .duration(3000)
        //   .call(y_temp);

        var y_rain = d3.scaleLinear()
          .domain([0, Math.max(50, d3.max(climate_data, d => parseFloat(d.precipitation)) * 1.2)])
          .range([height, 0]);
        svg_chart.append("g")
          .attr('transform', 'translate(' + height + ',' + 0 + ')')
          .call(d3.axisRight(y_rain));


        svg_chart.selectAll("mybar")
          .data(climate_data)
          .enter()
          .append("rect")
            .attr("x", d => x(d.month - 0.4) )
            .attr("y", d => y_rain(d.precipitation))
            .attr("width", (x(1) - x(0)) * 0.8)
            .attr("height", d => height - y_rain(d.precipitation))
            .attr("fill", "#66b6d2")
            .attr("style", "stroke-width:1; stroke:#1e7898;");

        // Temperatures
        svg_chart.append("path")
          .datum(climate_data)
          .attr("class","lineTemp")
          .attr("fill", "none")
          .attr("stroke", "#003399")
          .attr("stroke-width", 2)
          .attr("d", d3.line()
            .x(d => x(d.month))
            .y(d => y_temp(d.mintemp))
          );
        svg_chart.append("path")
          .datum(climate_data)
          .attr("class","lineTemp")
          .attr("fill", "none")
          .attr("stroke", "#b30000")
          .attr("stroke-width", 2)
          .attr("d", d3.line()
            .x(d => x(d.month))
            .y(d => y_temp(d.maxtemp))
          );
        svg_chart.selectAll("myCircles")
          .data(climate_data)
          .enter()
          .append("circle")
            .attr("fill", "#003399")
            // .attr("stroke", "#ffffff00")
            .attr("cx", d => x(d.month))
            .attr("cy", d => y_temp(d.mintemp))
            .attr("r", 3)
        svg_chart.selectAll("myCircles")
          .data(climate_data)
          .enter()
          .append("circle")
            .attr("fill", "#b30000")
            // .attr("stroke", "#ffffff00")
            .attr("cx", d => x(d.month))
            .attr("cy", d => y_temp(d.maxtemp))
            .attr("r", 3)

        // add wet days
        svg_chart.selectAll(".text")
          .data(climate_data)
          .enter()        
          .append("text")
          .attr("class","caption")
          .attr("text-anchor", "middle")
          .attr("x", d => x(d.month))
          .attr("y", height - 3)
          .attr("font-size", "10")
          .text(d => parseInt(d.wetdays));  
        
        // add label
        svg_chart.selectAll(".text")
          .data(climate_data)
          .enter()        
          .append("text")
          .attr("class","caption")
          .attr("text-anchor", "middle")
          .attr("x", height / 2)
          .attr("y", -20)
          .attr("dy", ".2em")
          .text("üìç " + lat.toFixed(2) + "¬∞N, " + lng.toFixed(2) + "¬∞E");  

        svg_chart.append("text")
          .attr("class", "x label")
          // .attr("text-anchor", "end")
          .attr("x", 2)
          .attr("y", 5)
          .attr("font-size", "10")
          .text("Max/min Temp.(¬∞C)");
        
        svg_chart.append("text")
          .attr("class", "x label")
          .attr("text-anchor", "end")
          .attr("x", height - 2)
          .attr("y", 5)
          .attr("font-size", "10")
          .text("Precip.(mm)");

        svg_chart.append("text")    
          .attr("class","wetdays-label")
          .attr("text-anchor", "middle")
          .attr("x", height / 2)
          .attr("y", height - 15)
          .attr("font-size", "10")
          .attr("style", "italics")
          .text("Wet days");

        svg_chart.append("text")
          .attr("class", "x label")
          .attr("text-anchor", "end")
          .attr("x", 0)
          .attr("y", height + 16)
          .attr("font-size", "10")
          .text("Month");
      }
      map.on('click', onMapClick);
    }
  )


  render_map(1);

  var slider = d3
    .sliderHorizontal()
    .min(1)
    .max(12)
    .step(1)
    .width(250)
    .displayValue(false)
    .on('onchange', (val) => {
      // d3.select('#value').text(val);
      // map.eachLayer(function (layer) {
      //     map.removeLayer(layer);
      // });
      // d3.select('#value').text(month_name[val-1])
      render_map(val);
    });

  d3.select('#slider')
    .append('svg')
    // .attr('width', '')
    // .attr('height', '70')
    .append('g')
    .attr('transform', 'translate(20,20)')
    .call(slider);

  
</script>


<!-- <script>

  // Basemap
  var map = L.map("map").setView([50, 20], 4);
  var url = 'https://stamen-tiles.a.ssl.fastly.net/toner/{z}/{x}/{y}.png';
  L.tileLayer(url, {
    attribution: "OSM & Carto",
    subdomains: "abcd",
    maxZoom: 16
  }).addTo(map);


  // Layer Control
//   var layerControl = L.control.layers(baseMaps, overlayMaps).addTo(map);
//   var baseMaps = {
//     "<span style='color: gray'>Grayscale</span>": grayscale,
//     "Streets": streets
//   };

  // GeoTIFF
  var tiff = "./data/relativeMap2.tif";



  d3.request(tiff).responseType('arraybuffer').get(
            function (error, tiffData) {
                let s = L.ScalarField.fromGeoTIFF(tiffData.response);

                let relativeMap = L.canvasLayer.scalarField(s, {
                    opacity: 0.5,
                    color: chroma.scale('YlOrRd').domain(s.range),
                    interpolate: false
                }).addTo(map);

                relativeMap.on('click', function (e) {
                    if (e.value !== null) {
                        let v = e.value.toFixed(2);
                        let html = (`<span class="popupText">Score ${v}</span>`);
                        let popup = L.popup()
                            .setLatLng(e.latlng)
                            .setContent(html)
                            .openOn(map);
                    }
                });
                // map.fitBounds(layer.getBounds());




                // Layer Control
                L.control.layers({
                    "December": relativeMap,
                    "December": relativeMap
                }, {}, {
                    position: 'topright',
                    collapsed: false
                    }).addTo(map);


            });
  




  // d3.request(tiff).responseType('arraybuffer').get(
  //   function(error, tiffData) {
  //     var s = L.ScalarField.fromGeoTIFF(buffer);
  //     let layer = L.canvasLayer.scalarField(s, {
  //       color: chroma.scale('OrRd').domain(s.range),
  //       opacity: 0.7,
  //       interpolate: false,
  //       mouseMoveCursor: null,
  //   }).addTo(map);


  //   // Add score info panel

  //   var info = L.control();

  //   info.onAdd = function (map) {
  //       this._div = L.DomUtil.create('div', 'info'); // create a div with a class "info"
  //       this.update();
  //       return this._div;
  //   };

  //   // method that we will use to update the control based on feature properties passed
  //   info.update = function (props) {
  //       this._div.innerHTML = '<h4>Relative score</h4>' +  (props!=null ?
  //           props
  //           : 'Hover over a state');
  //   };

  //   info.addTo(map);


  //   layer.on("click", function(e){
  //     if (e.value!=null){
  //       info.update(e.value);
  //     }
  //   })


  //   // map.fitBounds(layer.getBounds());
  // });

</script> -->

</body>
</html>